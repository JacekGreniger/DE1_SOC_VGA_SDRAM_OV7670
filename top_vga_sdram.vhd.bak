--freeze 2
-- fifo reads data from sdram, there are colour strips but they are scrolling vertically, probably data are dropped instead of writing to fifo
--
--freeze 4
-- all works properly, three strips on the screen but it looks one pixel is shifted
--
--freeze 5
-- rework and switch to 16bit per pixel

--freeze 6
-- draw circle, fifo size decreased to 1024 words

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity Max1000_Wasserwaage_SDRAM is
	port (
		CLOCK_50									: in		std_logic;
		RESETn									: in		std_logic;

		DRAM_ADDR								: out		std_logic_vector(12 downto 0);
		DRAM_BA									: out		std_logic_vector(1 downto 0);
		DRAM_CAS_N								: out		std_logic;
		DRAM_CKE								: out		std_logic;
		DRAM_CS_N							: out		std_logic;
		DRAM_DQ								: inout	std_logic_vector(15 downto 0);
		DRAM_LDQM							: out		std_logic;
		DRAM_UDQM							: out		std_logic;
		DRAM_RAS_N							: out		std_logic;
		DRAM_WE_N							: out		std_logic;
		DRAM_CLK								: out		std_logic;

		VGA_BLANK_N : out STD_LOGIC;
		VGA_B : out STD_LOGIC_VECTOR(7 downto 0);
		VGA_CLK : out STD_LOGIC;
		VGA_G : out STD_LOGIC_VECTOR(7 downto 0);
		VGA_HS : out STD_LOGIC;
		VGA_R : out STD_LOGIC_VECTOR(7 downto 0);
		VGA_SYNC_N : out STD_LOGIC;
		VGA_VS : out STD_LOGIC;
	
		KEY : in std_logic_vector(3 downto 0);
		LEDR : out std_logic_vector(9 downto 0);
		SW : in std_logic_vector(9 downto 0)
	);
end entity;

architecture content of Max1000_Wasserwaage_SDRAM is
	signal clk_int80						: std_logic;
	signal pll_sys_locked				: std_logic;
	signal reset_int_n					: std_logic;
	signal led_int							: std_logic_vector(7 downto 0);
	signal vga_clk 						: std_logic;
	
	component PLL_SYS
		port (
			inclk0								: in		std_logic := '0';
			c0										: out		std_logic;
			c1										: out		std_logic;
			c2										: out		std_logic;
			locked								: out		std_logic 
		);
	end component;

	component RESET_GEN
		port (
			clk_in								: in		std_logic;
			reset_n_1							: in		std_logic;
			reset_n_2							: in		std_logic;
			reset_out_n							: out		std_logic
		);
	end component;
	

	component NIOS is
        port (
            clk_clk                       : in    std_logic                     := 'X';             -- clk
            reset_reset_n                 : in    std_logic                     := 'X';             -- reset_n
            sdram_controller_0_wire_addr  : out   std_logic_vector(11 downto 0);                    -- addr
            sdram_controller_0_wire_ba    : out   std_logic_vector(1 downto 0);                     -- ba
            sdram_controller_0_wire_cas_n : out   std_logic;                                        -- cas_n
            sdram_controller_0_wire_cke   : out   std_logic;                                        -- cke
            sdram_controller_0_wire_cs_n  : out   std_logic;                                        -- cs_n
            sdram_controller_0_wire_dq    : inout std_logic_vector(15 downto 0) := (others => 'X'); -- dq
            sdram_controller_0_wire_dqm   : out   std_logic_vector(1 downto 0);                     -- dqm
            sdram_controller_0_wire_ras_n : out   std_logic;                                        -- ras_n
            sdram_controller_0_wire_we_n  : out   std_logic;                                        -- we_n
            avalon_mm_address             : in    std_logic_vector(21 downto 0) := (others => 'X'); -- address
            avalon_mm_byteenable_n        : in    std_logic_vector(1 downto 0)  := (others => 'X'); -- byteenable_n
            avalon_mm_chipselect          : in    std_logic                     := 'X';             -- chipselect
            avalon_mm_writedata           : in    std_logic_vector(15 downto 0) := (others => 'X'); -- writedata
            avalon_mm_read_n              : in    std_logic                     := 'X';             -- read_n
            avalon_mm_write_n             : in    std_logic                     := 'X';             -- write_n
            avalon_mm_readdata            : out   std_logic_vector(15 downto 0);                    -- readdata
            avalon_mm_readdatavalid       : out   std_logic;                                        -- readdatavalid
            avalon_mm_waitrequest         : out   std_logic                                         -- waitrequest
        );
    end component NIOS;	

	component vga_fifo
	PORT
	(
		aclr		: IN STD_LOGIC  := '0';
		data		: IN STD_LOGIC_VECTOR (15 DOWNTO 0);
		rdclk		: IN STD_LOGIC ;
		rdreq		: IN STD_LOGIC ;
		wrclk		: IN STD_LOGIC ;
		wrreq		: IN STD_LOGIC ;
		q			: OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
		rdempty		: OUT STD_LOGIC ;
		rdfull		: OUT STD_LOGIC ;
		wrempty		: OUT STD_LOGIC ;
		wrfull		: OUT STD_LOGIC ;
		wrusedw		: OUT STD_LOGIC_VECTOR (9 DOWNTO 0)
	);
	end component;
	
	component vga_gen
    port ( 
	 	PIXEL_CLOCK : in std_logic; 
		RESET_N : in std_logic;
		VGA_HSYNC_OUT : out  STD_LOGIC;
		VGA_VSYNC_OUT : out  STD_LOGIC;
		VGA_R_OUT : out  STD_LOGIC;
		VGA_G_OUT : out  STD_LOGIC;
		VGA_B_OUT : out  STD_LOGIC;

		--FIFO interface
		FIFO_RDREQ		: out STD_LOGIC ;
		FIFO_Q			: in STD_LOGIC_VECTOR (15 DOWNTO 0);
		FIFO_RDEMPTY		: in STD_LOGIC ;
		FIFO_RDFULL		: in STD_LOGIC	
	);
	end component;

signal vga_fifo_data		: STD_LOGIC_VECTOR (15 DOWNTO 0);
signal vga_fifo_rdreq		: STD_LOGIC ;
signal vga_fifo_wrreq		: STD_LOGIC ;
signal vga_fifo_q			: STD_LOGIC_VECTOR (15 DOWNTO 0);
signal vga_fifo_rdempty		: STD_LOGIC ;
signal vga_fifo_rdfull		: STD_LOGIC ;
signal vga_fifo_wrempty		: STD_LOGIC ;
signal vga_fifo_wrfull		: STD_LOGIC ;

signal avalon_mm_address             : std_logic_vector(21 downto 0) := (others => 'X'); -- address
signal avalon_mm_byteenable_n        : std_logic_vector(1 downto 0)  := (others => 'X'); -- byteenable_n
signal avalon_mm_chipselect          : std_logic                     := 'X';             -- chipselect
signal avalon_mm_writedata           : std_logic_vector(15 downto 0) := (others => 'X'); -- writedata
signal avalon_mm_read_n              : std_logic                     := 'X';             -- read_n
signal avalon_mm_write_n             : std_logic                     := 'X';             -- write_n
signal avalon_mm_readdata            : std_logic_vector(15 downto 0);                    -- readdata
signal avalon_mm_readdatavalid       : std_logic;                                        -- readdatavalid
signal avalon_mm_waitrequest         : std_logic;                                       -- waitrequest

signal read_addr : std_logic_vector(21 downto 0) := (others => '0');
signal write_addr : std_logic_vector(21 downto 0) := (others => '0');
signal read_addr_next : std_logic_vector(21 downto 0) := (others => '0');
signal write_addr_next : std_logic_vector(21 downto 0) := (others => '0');
	 
signal sdram_write : std_logic := '0';

signal vga_fifo_wrusedw : std_logic_vector(9 downto 0);
signal vga_fifo_almost_empty : std_logic;
signal vga_fifo_almost_full : std_logic;
	
signal fifo_wr_allowed : std_logic;
signal fifo_flag_sel			: std_logic;
signal fifo_flag_sel_next	: std_logic;

signal write_x : integer range 0 to 1023 := 0;
signal write_x_next : integer range 0 to 1023 := 0;
signal write_y : integer range 0 to 1023 := 0;
signal write_y_next : integer range 0 to 1023 := 0;

signal DRAM_DQM : std_logic_vector(1 downto 0);

begin

	DRAM_LDQM<=DRAM_DQM(0);
	DRAM_UDQM<=DRAM_DQM(1);
	VGA_BLANK_N<='1';
	VGA_SYNC_N<='0';
					
		u0 : component PLL_SYS
		port map (
			inclk0								=> CLOCK_50,
			c0										=> clk_int80,
			c1										=> SDRAM_CLK,
			c2										=> vga_clk,
			locked								=> pll_sys_locked
		);

		u1 : component RESET_GEN
		port map (
			clk_in								=> clk_int80,
			reset_n_1							=> RESETn,
			reset_n_2							=> pll_sys_locked,
			reset_out_n							=> reset_int_n
		);
		
		u2 : component NIOS
		port map (
			clk_clk								=> clk_int80,
			reset_reset_n						=> reset_int_n,
			sdram_controller_0_wire_addr	=> DRAM_ADDR(11 downto 0),						-- comment this line, if the full address width of 14 bits is required
			sdram_controller_0_wire_ba		=> DRAM_BA,
			sdram_controller_0_wire_cas_n	=> DRAM_CAS_N,
			sdram_controller_0_wire_cke	=> DRAM_CKE,
			sdram_controller_0_wire_cs_n	=> DRAM_CS_N,
			sdram_controller_0_wire_dq		=> DRAM_DQ,
			sdram_controller_0_wire_dqm	=> DRAM_DQM,
			sdram_controller_0_wire_ras_n	=> DRAM_RAS_N,
			sdram_controller_0_wire_we_n	=> DRAM_WE_N,
         avalon_mm_address             => avalon_mm_address,             --               avalon_mm.address
         avalon_mm_byteenable_n        => avalon_mm_byteenable_n,        --                        .byteenable_n
         avalon_mm_chipselect          => avalon_mm_chipselect,          --                        .chipselect
         avalon_mm_writedata           => avalon_mm_writedata,           --                        .writedata
         avalon_mm_read_n              => avalon_mm_read_n,              --                        .read_n
         avalon_mm_write_n             => avalon_mm_write_n,             --                        .write_n
         avalon_mm_readdata            => avalon_mm_readdata,            --                        .readdata
         avalon_mm_readdatavalid       => avalon_mm_readdatavalid,       --                        .readdatavalid
         avalon_mm_waitrequest         => avalon_mm_waitrequest          --                        .waitrequest
		);

		avalon_mm_byteenable_n <= "00"; --both bytes enabled
		avalon_mm_chipselect <= '1';
		
		vga_fifo_inst : vga_fifo 
		PORT MAP (
			aclr => not reset_int_n,
		
			data	 => vga_fifo_data,
			wrclk	 => clk_int80,
			wrreq	 => vga_fifo_wrreq,
			wrempty	 => vga_fifo_wrempty,
			wrfull	 => vga_fifo_wrfull,

			q	 => vga_fifo_q,
			rdclk	 => vga_clk,
			rdreq	 => vga_fifo_rdreq,
			rdempty	 => vga_fifo_rdempty,
			rdfull	 => vga_fifo_rdfull,
			wrusedw	=> vga_fifo_wrusedw
		);
		
		
		led_int <= sdram_write&avalon_mm_read_n&avalon_mm_readdatavalid&avalon_mm_waitrequest&
					vga_fifo_rdempty&vga_fifo_wrreq&vga_fifo_almost_full&vga_fifo_almost_empty;

		vga_fifo_almost_empty <= '1' when to_integer(unsigned(vga_fifo_wrusedw))<64 else '0';
		vga_fifo_almost_full <= '1' when to_integer(unsigned(vga_fifo_wrusedw))>1000 else '0';
		fifo_wr_allowed <= (not vga_fifo_almost_full) when fifo_flag_sel='1' else vga_fifo_almost_empty;

      avalon_mm_read_n <= (not fifo_wr_allowed) when sdram_write='0' else '1';

		gen_image: process (read_addr, avalon_mm_read_n, fifo_wr_allowed, avalon_mm_readdatavalid, avalon_mm_waitrequest, sdram_write) is
		begin
			if sdram_write='0' then
				if fifo_wr_allowed='1' and avalon_mm_waitrequest='0' and avalon_mm_read_n='0' then
					--address increment when read asserted and sdram controller is ready to queue request
					if to_integer(unsigned(read_addr)) < (640*480-1) then
						read_addr_next <= std_logic_vector(to_unsigned(to_integer(unsigned(read_addr)) + 1, 22));
					else
						read_addr_next <= (others=>'0');
					end if;
				else
					read_addr_next <= read_addr;
				end if;
			else
				read_addr_next <= (others=>'0');				
			end if;
		end process;

		process (fifo_flag_sel, vga_fifo_almost_full, vga_fifo_almost_empty)
		begin
			if vga_fifo_almost_full='0' and vga_fifo_almost_empty='1' then
				fifo_flag_sel_next <= '1';
			elsif fifo_flag_sel <= '1' and vga_fifo_almost_full='1' then
				fifo_flag_sel_next <= '0';
			else
				fifo_flag_sel_next <= fifo_flag_sel;
			end if;
		end process;
		
		process (clk_int80, reset_int_n) is
		begin
			if reset_int_n = '0' then
				fifo_flag_sel <= '1';		
			elsif rising_edge(clk_int80) then
				fifo_flag_sel <= fifo_flag_sel_next;
			end if;
		end process;

		gen_image_seq: process (clk_int80, reset_int_n) is
		begin
			if reset_int_n = '0' then
				read_addr <= (others=>'0');		
			elsif rising_edge(clk_int80) then
				read_addr <= read_addr_next;
			end if;
		end process;

		
		vga_fifo_wrreq <= avalon_mm_readdatavalid;
		vga_fifo_data <= avalon_mm_readdata;

		avalon_mm_address <= write_addr when sdram_write='1' else read_addr;

		
		-- WRITE PART
		sdram_write <= '1' when to_integer(unsigned(write_addr)) < 640*480 else '0';
		avalon_mm_write_n <= not sdram_write;
		
		avalon_mm_writedata(15 downto 3) <= "0000000000000";

		sdram_write_comb: process (write_addr, avalon_mm_waitrequest, sdram_write, write_x, write_y) is
		begin
			avalon_mm_writedata(2 downto 0) <= "000";
			
			if (write_x>100 and write_x<200 and write_y>100 and write_y<200) then
				avalon_mm_writedata(2 downto 0) <= "111";
			elsif to_integer(unsigned(write_addr)) < 640*160 then
				avalon_mm_writedata(2 downto 0) <= "100";
			elsif to_integer(unsigned(write_addr)) < 640*320 then
				avalon_mm_writedata(2 downto 0) <= "010";
			else
				avalon_mm_writedata(2 downto 0) <= "001";
			end if;
			
			if ((write_x-300)*(write_x-300)+(write_y-300)*(write_y-300)>8000)and ((write_x-300)*(write_x-300)+(write_y-300)*(write_y-300)<10000) then
				avalon_mm_writedata(2 downto 0) <= "110";
			end if;
			
			write_addr_next <= write_addr;
			write_x_next <= write_x;
			write_y_next <= write_y;
	
			if (avalon_mm_waitrequest = '0') and (sdram_write='1') then
				write_addr_next <= std_logic_vector(to_unsigned(to_integer(unsigned(write_addr)) + 1, 22));

				if write_x >= 639 then
					write_x_next <= 0;
					if write_y >= 479 then
						write_y_next <= 0;
					else
						write_y_next <= write_y + 1;
					end if;
				else
					write_x_next <= write_x + 1;
				end if;
			end if;
		end process;
		
		sdram_write_seq: process (clk_int80, reset_int_n) is
		begin
			if reset_int_n = '0' then
				write_addr <= (others=>'0');
				write_x <= 0;
				write_y <= 0;
			elsif rising_edge(clk_int80) then
				write_addr <= write_addr_next;
				write_x <= write_x_next;
				write_y <= write_y_next;
				
			end if;
		end process;		
		
		vga_gen_inst : component vga_gen
		port map ( 
			PIXEL_CLOCK => vga_clk,
			RESET_N => reset_int_n,
			VGA_HSYNC_OUT => VGA_HS,
			VGA_VSYNC_OUT => VGA_VS,
			VGA_R_OUT => VGA_R_OUT,
			VGA_G_OUT => VGA_G_OUT,
			VGA_B_OUT => VGA_B_OUT,
			FIFO_RDREQ => vga_fifo_rdreq,
			FIFO_Q => vga_fifo_q,
			FIFO_RDEMPTY => vga_fifo_rdempty,
			FIFO_RDFULL	=>	vga_fifo_rdfull
		);
			

	LEDR <= "00"&led_int;
	
	DRAM_ADDR(12) <= '0';																				-- comment this line, if the full address width of 14 bits is required
end architecture;